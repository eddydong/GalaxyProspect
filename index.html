<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GalaxyProspect Dashboard</title>
    <script src="/static/echarts.min.js"></script>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <aside class="sidebar">
        <div class="sidebar-bevel"></div>
        <div class="sidebar-top-icons">
            <div class="sidebar-icon mode-panel-icon" data-panel="mode" title="Chart Mode">
                <svg viewBox="0 0 32 32" fill="none" width="32" height="32">
                    <ellipse cx="16" cy="16" rx="12" ry="8" stroke="currentColor" stroke-width="2" fill="none"/>
                    <circle cx="16" cy="16" r="4.5" fill="currentColor"/>
                    <circle cx="16" cy="16" r="2.2" fill="#232837"/>
                </svg>
            </div>
            <div class="sidebar-icon" data-panel="series" title="Series Selection">
                <svg viewBox="0 0 32 32" fill="none" width="32" height="32">
                    <rect x="5.5" y="13.5" width="4" height="13" rx="1.3" fill="currentColor"/>
                    <rect x="13" y="7.5" width="5" height="17" rx="1.3" fill="currentColor"/>
                    <rect x="22" y="17.5" width="4" height="9" rx="1.3" fill="currentColor"/>
                </svg>
            </div>
        </div>
        <div class="sidebar-bottom-icons">
            <div class="sidebar-icon" data-panel="help" title="Help" id="help-btn">
                <svg viewBox="0 0 32 32" fill="none" width="32" height="32">
                    <circle cx="16" cy="16" r="12.5" stroke="currentColor" stroke-width="2" fill="none"/>
                    <g>
                        <path d="M16 22h0" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        <path d="M16 10a4 4 0 0 1 4 4c0 2-2 3-2 3s-2 1-2 3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </g>
                </svg>
            </div>
            <div class="sidebar-icon" data-panel="settings" title="Settings">
                <svg viewBox="0 0 32 32" fill="none" width="32" height="32">
                    <circle cx="16" cy="16" r="12.5" stroke="currentColor" stroke-width="2" fill="none"/>
                    <g>
                        <circle cx="16" cy="16" r="3.5" fill="currentColor"/>
                        <path d="M16 6v4M16 22v4M6 16h4M22 16h4M10.5 10.5l2.2 2.2M20 20l2.2 2.2M10.5 21.5l2.2-2.2M20 12l2.2-2.2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    </g>
                </svg>
            </div>
        </div>
    </aside>
    <main class="main-window">
        <div id="chart-container">
            <div id="casinoChart"></div>
            <div class="chart-bottom-spacer"></div>
        </div>
    </main>
    <div class="floating-panel" id="panel-mode">
        <div class="mode-card">
            <label class="mode-panel-label">Data View Mode</label>
            <div id="mode-options" class="mode-options">
                <button class="mode-btn" data-mode="raw">Raw</button>
                <button class="mode-btn" data-mode="normalized">Normalized</button>
                <button class="mode-btn" data-mode="indexed">Indexed</button>
            </div>
        </div>
        <div class="mode-card">
            <label class="mode-panel-label">Line Chart Mode</label>
            <button class="mode-btn" id="smooth-btn">Smooth Line</button>
        </div>
    </div>
    <div class="floating-panel" id="panel-series">
        <div id="series-categories" class="series-categories"></div>
    </div>
<div id="about-modal" class="about-modal">
    <div class="about-content">
        <div class="about-logo" style="margin-bottom:18px;">
            <!-- SVG LOGO: Theme color circle, two overlapping squares full opacity, overlapped part transparent -->
            <svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="36" cy="36" r="22" stroke="#00bcd4" stroke-width="5" fill="none"/>
                <g>
                    <defs>
                        <!-- Mask for first square: cut out overlap area -->
                        <mask id="cut1">
                            <rect x="0" y="0" width="72" height="72" fill="white"/>
                            <rect x="30" y="30" width="20" height="20" fill="black"/>
                        </mask>
                        <!-- Mask for second square: cut out overlap area -->
                        <mask id="cut2">
                            <rect x="0" y="0" width="72" height="72" fill="white"/>
                            <rect x="22" y="22" width="20" height="20" fill="black"/>
                        </mask>
                    </defs>
                    <!-- First square: bottom-left, with overlap cut out -->
                    <rect x="22" y="22" width="20" height="20" fill="#00bcd4" mask="url(#cut1)"/>
                    <!-- Second square: top-right, with overlap cut out -->
                    <rect x="30" y="30" width="20" height="20" fill="#00bcd4" mask="url(#cut2)"/>
                </g>
            </svg>
        </div>
        <div class="product-name">Macau Casino Indices</div>
    <div style="color:#00bcd4; margin-bottom:10px;">Version 0.01</div>
        <div style="margin-bottom:2px;">By Eddy K. Dong</div>
        <div style="margin-bottom:2px;">All Rights Reserved, 2025</div>
    </div>
</div>

    <script>
    // Disable all default scroll, selection, and drag for the whole page
    document.addEventListener('wheel', function(e) { e.preventDefault(); }, { passive: false });
    document.addEventListener('selectstart', function(e) { e.preventDefault(); });
    document.addEventListener('dragstart', function(e) { e.preventDefault(); });
    document.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });

    // About modal show/hide logic
    function showAbout() {
    var modal = document.getElementById('about-modal');
    modal.classList.add('visible');
    }
    document.getElementById('about-modal').addEventListener('click', function() {
        this.classList.remove('visible');
    });
    // Make the help button open the About modal
    document.getElementById('help-btn').addEventListener('click', function(e) {
        showAbout();
        e.stopPropagation();
    });
        // Block all horizontal (sideways) scroll on sidebar and chart, only allow vertical for chart panning
        function handleWheel(e) {
            // Always block horizontal scroll (deltaX) to prevent browser history navigation
            if (Math.abs(e.deltaX) > 0) {
                e.preventDefault();
                return;
            }
            // Only pan if NO modifier keys are held (pure scroll)
            if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) {
                // Do not pan chart if any modifier is held
                return;
            }
            // Only pan if chart is initialized and vertical scroll
            if (window.casinoChart && typeof casinoChart.dispatchAction === 'function' && Math.abs(e.deltaY) > 0) {
                const pan = e.deltaY;
                const option = casinoChart.getOption();
                const dz = option.dataZoom && option.dataZoom[0];
                if (dz) {
                    const total = option.xAxis[0].data.length;
                    const windowSize = Math.round((dz.end - dz.start) / 100 * total);
                    // Pan by 5% of window size per wheel event
                    const panStep = Math.max(1, Math.round(windowSize * 0.05));
                    let start = Math.round(dz.start / 100 * (total - 1));
                    let end = Math.round(dz.end / 100 * (total - 1));
                    if (pan > 0) {
                        // Pan right
                        start = Math.min(total - windowSize, start + panStep);
                        end = Math.min(total - 1, end + panStep);
                    } else {
                        // Pan left
                        start = Math.max(0, start - panStep);
                        end = Math.max(windowSize - 1, end - panStep);
                    }
                    const newStart = (start / (total - 1)) * 100;
                    const newEnd = (end / (total - 1)) * 100;
                    casinoChart.dispatchAction({
                        type: 'dataZoom',
                        start: newStart,
                        end: newEnd
                    });
                    e.preventDefault();
                }
            }
        }
        document.querySelector('.sidebar').addEventListener('wheel', handleWheel, { passive: false });
        document.getElementById('casinoChart').addEventListener('wheel', handleWheel, { passive: false });
        // Also block horizontal scroll globally to prevent browser navigation
        document.addEventListener('wheel', function(e) {
            if (Math.abs(e.deltaX) > 0) e.preventDefault();
        }, { passive: false });

        // Sidebar panel hover logic for two icons
        document.addEventListener('DOMContentLoaded', function() {
            const icons = [
                { icon: document.querySelector('.sidebar-icon[data-panel="mode"]'), panel: document.getElementById('panel-mode') },
                { icon: document.querySelector('.sidebar-icon[data-panel="series"]'), panel: document.getElementById('panel-series') }
            ];
            let panelTimeout = null;
            icons.forEach(({icon, panel}) => {
                icon.addEventListener('mouseenter', (e) => {
                    document.querySelectorAll('.floating-panel').forEach(p => p.classList.remove('active'));
                    if (panel) {
                        const rect = icon.getBoundingClientRect();
                        const sidebarWidth = icon.parentElement.offsetWidth;
                        panel.style.display = 'block';
                        const panelHeight = panel.offsetHeight || 480;
                        panel.style.display = '';
                        let top = rect.top + window.scrollY + rect.height/2 - panelHeight/2;
                        top = Math.max(16, Math.min(top, window.innerHeight - panelHeight - 16));
                        panel.style.left = sidebarWidth + 'px';
                        panel.style.top = top + 'px';
                        panel.classList.add('active');
                        icon.classList.add('active');
                    }
                });
                icon.addEventListener('mouseleave', () => {
                    panelTimeout = setTimeout(() => {
                        if (panel) panel.classList.remove('active');
                        icon.classList.remove('active');
                    }, 200);
                });
                if (panel) {
                    panel.addEventListener('mouseenter', () => {
                        clearTimeout(panelTimeout);
                        panel.classList.add('active');
                        icon.classList.add('active');
                    });
                    panel.addEventListener('mouseleave', () => {
                        panel.classList.remove('active');
                        icon.classList.remove('active');
                    });
                }
            });

            // Mode button highlight logic
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('mousedown', function() {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                });
            });
        });

        // Load config.json for symbol metadata and categories
    let configData = { symbols: [] };
        let symbolNames = {};
        let symbolCategories = { company: [], index: [], fx: [], commodity: [], macro: [] };
        function categorizeSymbols() {
            // Build symbolNames and symbolCategories from configData.symbols using 'category'
            symbolNames = {};
            symbolCategories = {};
            (configData.symbols || []).forEach(item => {
                symbolNames[item.field_name] = item.desc;
                const cat = item.category || 'Other';
                if (!symbolCategories[cat]) symbolCategories[cat] = [];
                symbolCategories[cat].push(item.field_name);
            });
        }

        // Ensure font is loaded before rendering
        if (document.fonts && document.fonts.ready) {
            document.fonts.ready.then(() => {
                setTimeout(main, 20);
            });
        } else {
            window.addEventListener('DOMContentLoaded', main);
        }

        async function fetchConfig() {
            const res = await fetch('/static/config.json');
            configData = await res.json();
            categorizeSymbols();
        }

        async function fetchData() {
            // Fetch all data from backend (no date range)
            const res = await fetch('/api/daily');
            const docs = await res.json();
            // Transform to: { symbol: { date: { 'Adj Close': value }, ... }, ... }
            const symbolData = {};
            docs.forEach(doc => {
                const date = doc._id;
                const data = doc.data || {};
                Object.keys(data).forEach(symbol => {
                    if (!symbolData[symbol]) symbolData[symbol] = {};
                    // If the field is an object with a 'value' key, use that for charting
                    let val = data[symbol];
                    if (val && typeof val === 'object' && 'value' in val) {
                        val = val.value;
                    }
                    symbolData[symbol][date] = { 'Adj Close': val };
                });
            });
            return symbolData;
        }

        // Shared color palette for all chart and UI coloring
        const BASE_COLORS = [
            '#FFD600', // Galaxy - Vivid Yellow
            '#00E676', // SJM - Bright Green
            '#FF1744', // Wynn - Vivid Red
            '#2979FF', // Sands - Bright Blue
            '#F500A3', // MGM - Magenta
            '#FF9100', // Melco - Orange
            '#00B8D4', // Hang Seng - Cyan
            '#C51162', // Shanghai - Deep Pink
            '#AEEA00'  // Shenzhen - Lime
        ];
        function hexToRgba(hex, alpha) {
            hex = hex.replace('#', '');
            if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
            const num = parseInt(hex, 16);
            const r = (num >> 16) & 255;
            const g = (num >> 8) & 255;
            const b = num & 255;
            return `rgba(${r},${g},${b},${alpha})`;
        }
        function getColor(idx) {
            return hexToRgba(BASE_COLORS[idx % BASE_COLORS.length], 0.9);
        }

    function prepareEChartsOption(selectedSymbols, data, normalized, indexed, opts = {}) {
        // Helper for K/M/B formatting
        function formatKMB(val) {
            if (val == null || isNaN(val)) return '';
            if (Math.abs(val) >= 1e12) return (val / 1e12).toFixed(1) + 't';
            if (Math.abs(val) >= 1e9) return (val / 1e9).toFixed(1) + 'b';
            if (Math.abs(val) >= 1e6) return (val / 1e6).toFixed(1) + 'm';
            if (Math.abs(val) >= 1e3) return (val / 1e3).toFixed(1) + 'k';
            return Number(val).toFixed(1);
        }
            // Always use the full union of all dates from all symbols for a stable x-axis
            // Generate a complete calendar date range from min to max date in the data
            let minDate = null, maxDate = null;
            Object.values(data).forEach(symbolData => {
                Object.keys(symbolData).forEach(date => {
                    const d = new Date(date);
                    if (!minDate || d < minDate) minDate = d;
                    if (!maxDate || d > maxDate) maxDate = d;
                });
            });

            // No volume data handling
            function formatDate(d) {
                const m = (d.getMonth() + 1).toString().padStart(2, '0');
                const day = d.getDate().toString().padStart(2, '0');
                return `${d.getFullYear()}-${m}-${day}`;
            }
            const sortedDates = [];
            if (minDate && maxDate) {
                for (let d = new Date(minDate); d <= maxDate; d.setDate(d.getDate() + 1)) {
                    sortedDates.push(formatDate(d));
                }
            }
            // Compute y-axis min/max based on visible (non-null) values in the current window for selected series
            let yMin = undefined, yMax = undefined;
            if (normalized) {
                yMin = 0;
                yMax = 1.05;
            } else if (indexed) {
                yMin = 0;
                yMax = undefined;
            } else if (selectedSymbols.length > 0) {
                // Always use the current dataZoom window for yMin/yMax in raw mode
                let windowRange = opts.windowRange;
                if (!windowRange && typeof getCurrentWindowRange === 'function') {
                    windowRange = getCurrentWindowRange();
                }
                if (!windowRange) windowRange = [0, sortedDates.length - 1];
                let allVisible = [];
                selectedSymbols.filter(symbol => data[symbol]).forEach(symbol => {
                    const entries = Object.entries(data[symbol]);
                    const dateToAdjClose = Object.fromEntries(entries.map(([date, v]) => [date, v['Adj Close'] ?? null]));
                    let values = sortedDates.map(date => dateToAdjClose[date] ?? null);
                    // Only consider values in the current window
                    values = values.slice(windowRange[0], windowRange[1] + 1);
                    allVisible.push(...values.filter(v => v != null && isFinite(v)));
                });
                if (allVisible.length > 0) {
                    yMin = Math.min(...allVisible);
                    yMax = Math.max(...allVisible);
                    if (yMin === yMax) {
                        // Add a small buffer if all values are the same
                        yMin = yMin * 0.98;
                        yMax = yMax * 1.02;
                    }
                } else {
                    yMin = null;
                    yMax = null;
                }
            }
            // Prepare series for each symbol
            const series = selectedSymbols.map((symbol, idx) => {
                if (!data[symbol]) return null; // skip if data missing
                const entries = Object.entries(data[symbol]);
                // Only use 'Adj Close', never fallback to 'Close'
                const dateToAdjClose = Object.fromEntries(entries.map(([date, v]) => [date, v['Adj Close'] ?? null]));
                let values = sortedDates.map(date => dateToAdjClose[date] ?? null);
                let actualValues = values.slice();
                if (normalized && values.filter(v => v != null).length > 0) {
                    // Min-max normalization: (value - min) / (max - min) within zoom window
                    let min, max, range;
                    if (opts.windowRange) {
                        const [start, end] = opts.windowRange;
                        const windowVals = values.slice(start, end + 1).filter(v => v != null);
                        min = windowVals.length ? Math.min(...windowVals) : 0;
                        max = windowVals.length ? Math.max(...windowVals) : 0;
                        range = max - min;
                        // Store actual values for tooltip
                        actualValues = values.slice();
                        values = values.map((v, i) => {
                            if (v == null) return null;
                            if (i < start || i > end) return null;
                            // Always return a number for real data, null for missing
                            return range === 0 ? 0 : (v - min) / range;
                        });
                    } else {
                        const valid = values.filter(v => v != null);
                        min = Math.min(...valid);
                        max = Math.max(...valid);
                        range = max - min;
                        // Store actual values for tooltip
                        actualValues = values.slice();
                        values = values.map((v, i) => v == null ? null : (range === 0 ? 0 : (v - min) / range));
                    }
                } else if (indexed && values.filter(v => v != null).length > 0 && opts.windowRange) {
                    // Indexed mode: divide by first non-null value in the current window
                    const [start, end] = opts.windowRange;
                    const windowVals = values.slice(start, end + 1);
                    const firstIdxInWindow = windowVals.findIndex(v => v != null);
                    const base = firstIdxInWindow !== -1 ? windowVals[firstIdxInWindow] : null;
                    // Store actual values for tooltip
                    actualValues = values.slice();
                    values = values.map((v, i) => {
                        if (v == null) return null;
                        if (base == null) return null;
                        // Always return a number for real data, null for missing
                        return i >= start && i <= end ? v / base : null;
                    });
                }
                return {
                    name: symbol + ' (' + (symbolNames[symbol] || symbol) + ') Adj Close',
                    type: 'line',
                    smooth: window.smoothLineEnabled === true,
                    data: values,
                    yAxisIndex: 0,
                    showSymbol: true,
                    symbol: 'circle',
                    symbolSize: 7,
                    symbolKeepAspect: true,
                    symbolSize: 7,
                    connectNulls: true,
                    lineStyle: { width: 2, color: getColor(idx) },
                    itemStyle: { color: getColor(idx) },
                    emphasis: { focus: 'series' },
                    tooltip: {
                        valueFormatter: function (value, i) {
                            if ((normalized || indexed) && typeof value === 'number' && typeof actualValues[i] === 'number') {
                                return value.toFixed(3) + ' (actual: ' + formatKMB(actualValues[i]) + ')';
                            } else if (typeof value === 'number') {
                                return formatKMB(value);
                            } else {
                                return 'N/A';
                            }
                        }
                    }
                };
            }).filter(Boolean);
            // No volume data handling
            // No volume data handling
            // Default to last 36 months (about 756 trading days)
            const defaultMonths = 36;
            const defaultDays = defaultMonths * 21; // ~21 trading days per month
            const defaultWindow = sortedDates.length > defaultDays ? Math.round((sortedDates.length - defaultDays) / sortedDates.length * 100) : 0;
            return {
                animation: false,
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'cross',
                        crossStyle: {
                            color: '#00bcd4',
                            width: 1.5
                        },
                        label: {
                            backgroundColor: '#232837',
                            color: '#fff',
                            borderColor: '#00bcd4',
                            borderWidth: 1,
                            fontWeight: 'bold',
                            fontSize: 16,
                            fontFamily: 'MCI',
                            padding: [6, 16],
                            margin: 0
                        }
                    },
                    backgroundColor: '#232837',
                    borderColor: '#fff',
                    textStyle: { color: '#fff', fontFamily: 'MCI' }
                },
                legend: { show: false, textStyle: { fontFamily: 'MCI' } },
                grid: { left: 52, right: 56, top: 85, bottom: 28 },
                dataZoom: [
                    {
                        type: 'slider',
                        show: true,
                        xAxisIndex: 0,
                        // Show only the most recent 36 months (about 756 trading days) by default
                        start: defaultWindow,
                        end: 100,
                        height: 22,
                        bottom: null,
                        top: 0, // Place slider at the very top of the chart area
                        backgroundColor: '#232837',
                        borderColor: '#333',
                        fillerColor: 'rgba(0,188,212,0.18)',
                        handleIcon: 'M8.7,11.3v-8.6h2.6v8.6H8.7z',
                        handleSize: '120%',
                        moveHandleSize: '100%',
                        showDetail: true,
                        handleStyle: { color: '#00bcd4' },
                        textStyle: { color: '#fff' },
                        minValueSpan: 30, // Minimum zoom window is 30 ticks
                        showDataShadow: true,
                        dataBackground: {
                            lineStyle: { color: '#00bcd4', opacity: 0.5 },
                            areaStyle: { color: 'rgba(0,188,212,0.10)' }
                        }
                    },
                    {
                        type: 'inside',
                        xAxisIndex: 0,
                        zoomOnMouseWheel: 'shift', // vertical scroll with shift pans
                        moveOnMouseWheel: true,    // horizontal scroll pans
                        moveOnMouseMove: true,
                        minValueSpan: 30 // Minimum zoom window is 30 ticks
                    }
                ],
                xAxis: {
                    type: 'category',
                    data: sortedDates,
                    axisLabel: {
                        rotate: 0, // Print horizontally
                        color: 'rgba(255,255,255,0.8)',
                        fontWeight: 500,
                        interval: 'auto', // Let ECharts auto-calculate, but force minInterval below
                        minInterval: 1, // Allow every tick if space
                        hideOverlap: true, // Never overlap
                        fontFamily: 'MCI',
                        letterSpacing: 2,
                        fontSize: 16,
                        // Always show at least 4 ticks: if ECharts shows fewer, force 4 evenly spaced
                        formatter: function(value, index) {
                            const total = sortedDates.length;
                            // If ECharts would show fewer than 4, force 4 evenly spaced
                            if (this.axis && this.axis.getViewLabels) {
                                const labels = this.axis.getViewLabels();
                                if (labels.length < 4) {
                                    const step = Math.max(1, Math.floor(total / 4));
                                    if (index % step !== 0 && index !== total - 1 && index !== 0) return '';
                                }
                            }
                            return value;
                        }
                    },
                    axisLine: { lineStyle: { color: 'rgba(255,255,255,0.8)' } }
                },
                yAxis: [
                    {
                        type: 'value',
                        name: normalized ? 'Normalized Adj Close' : 'Adj Close',
                        position: 'left',
                        axisLine: { show: true, lineStyle: { color: 'rgba(255,255,255,0.8)' } },
                        axisLabel: { formatter: v => normalized ? v.toFixed(3) : (typeof v === 'number' ? formatKMB(v) : v), color: 'rgba(255,255,255,0.8)', fontWeight: 500, fontFamily: 'MCI', letterSpacing: 2, fontSize: 16, margin: 8 },
                        nameTextStyle: { color: 'rgba(255,255,255,0.8)', fontWeight: 600, fontFamily: 'MCI', letterSpacing: 2, fontSize: 16 },
                        nameGap: 16,
                        splitLine: { lineStyle: { color: '#333' } },
                        min: yMin,
                        max: yMax,
                        axisPointer: { label: { margin: -8, padding: [6, 8] } }
                    },
                    {
                        type: 'value',
                        name: '',
                        position: 'right',
                        axisLine: { show: true, lineStyle: { color: 'rgba(255,255,255,0.8)' } },
                        axisLabel: { formatter: v => normalized ? v.toFixed(3) : (typeof v === 'number' ? formatKMB(v) : v), color: 'rgba(255,255,255,0.8)', fontWeight: 500, fontFamily: 'MCI', letterSpacing: 2, fontSize: 16, margin: 8 },
                        nameTextStyle: { color: 'rgba(255,255,255,0.8)', fontWeight: 600, fontFamily: 'MCI', letterSpacing: 2, fontSize: 16 },
                        nameGap: 16,
                        splitLine: { show: false },
                        min: yMin,
                        max: yMax,
                        axisPointer: { label: { margin: -8, padding: [6, 8] } }
                    }
                ],
                series: series.map(s => s.type === 'bar' ? { ...s, barMinWidth: 3 } : s)
            };
        }

        async function main() {
            await fetchConfig();
            const data = await fetchData();
            const symbols = Object.keys(data);

            // Use config-driven categories from config.json 'category' field
            const seriesCategories = document.getElementById('series-categories');
            seriesCategories.innerHTML = '';
            let anyChecked = false;
            // Get all unique categories, preserving order of first appearance
            const allCategories = [];
            (configData.symbols || []).forEach(item => {
                const cat = item.category || 'Other';
                if (!allCategories.includes(cat)) allCategories.push(cat);
            });
            const catCheckboxes = {};
            const categoryToCheckboxes = {};
            allCategories.forEach(cat => {
                const syms = symbolCategories[cat] || [];
                if (syms.length === 0) return;
                // Category label as direct child
                const labelDiv = document.createElement('div');
                labelDiv.className = 'category-label';
                const catCheckbox = document.createElement('input');
                catCheckbox.type = 'checkbox';
                catCheckbox.className = 'category-checkbox';
                catCheckbox.setAttribute('data-category', cat);
                labelDiv.appendChild(catCheckbox);
                labelDiv.appendChild(document.createTextNode(cat.toUpperCase()));
                catCheckboxes[cat] = catCheckbox;
                labelDiv.addEventListener('click', function(e) {
                    if (e.target !== catCheckbox) {
                        const cbs = categoryToCheckboxes[cat];
                        const allChecked = cbs.length > 0 && cbs.every(cb => cb.checked);
                        cbs.forEach(cb => { cb.checked = !allChecked; cb.dispatchEvent(new Event('change', {bubbles:true})); });
                        updateChart();
                    }
                });
                seriesCategories.appendChild(labelDiv);
                // Series checkboxes as direct children
                categoryToCheckboxes[cat] = [];
                syms.forEach(sym => {
                    const itemLabel = document.createElement('label');
                    itemLabel.setAttribute('data-symbol', sym);
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.value = sym;
                    cb.checked = false;
                    itemLabel.appendChild(cb);
                    itemLabel.appendChild(document.createTextNode(' ' + (symbolNames[sym] || sym)));
                    itemLabel.title = sym;
                    seriesCategories.appendChild(itemLabel);
                    categoryToCheckboxes[cat].push(cb);
                    // Check the first available symbol in the first category by default
                    if (!anyChecked && sym && data[sym]) {
                        cb.checked = true; anyChecked = true;
                    }
                    itemLabel.addEventListener('click', function(e) {
                        if (e.target === cb) return;
                        e.preventDefault();
                        cb.checked = !cb.checked;
                        cb.dispatchEvent(new Event('change', {bubbles:true}));
                        updateChart();
                    });
                    cb.addEventListener('change', function() {
                        const catCheckbox = catCheckboxes[cat];
                        const cbs = categoryToCheckboxes[cat];
                        const checkedCount = cbs.filter(cb2 => cb2.checked).length;
                        if (checkedCount === cbs.length && cbs.length > 0) {
                            catCheckbox.checked = true;
                        } else {
                            catCheckbox.checked = false;
                        }
                        catCheckbox.indeterminate = false;
                        updateChart();
                    });
                });
                // Add separator after last item in category
                const separator = document.createElement('div');
                separator.className = 'category-placeholder';
                seriesCategories.appendChild(separator);
                catCheckbox.addEventListener('change', function(e) {
                    const cbs = categoryToCheckboxes[cat];
                    cbs.forEach(cb => { cb.checked = catCheckbox.checked; cb.dispatchEvent(new Event('change', {bubbles:true})); });
                    updateChart();
                });
            });

            // Helper: batch check/uncheck children when category label is toggled
            // Store sync functions for each category
            const syncCatCheckboxFns = {};
            function setupCategoryBatchToggle(category, symbols, catCheckbox) {
                catCheckbox.addEventListener('change', function() {
                    const checked = catCheckbox.checked;
                    // Find the block for this category
                    const block = catCheckbox.closest('.category-block');
                    if (!block) return;
                    const cbs = Array.from(block.querySelectorAll('input[type=checkbox][value]'));
                    cbs.forEach(cb => { cb.checked = checked; });
                    updateChart();
                    // Always sync after batch toggle
                    if (typeof syncCatCheckboxFns[category] === 'function') syncCatCheckboxFns[category]();
                });
                function syncCatCheckbox() {
                    const block = catCheckbox.closest('.category-block');
                    if (!block) return;
                    const cbs = Array.from(block.querySelectorAll('input[type=checkbox][value]'));
                    const checkedCount = cbs.filter(cb => cb.checked).length;
                    if (checkedCount === cbs.length && cbs.length > 0) {
                        catCheckbox.checked = true;
                        catCheckbox.indeterminate = false;
                    } else if (checkedCount === 0) {
                        catCheckbox.checked = false;
                        catCheckbox.indeterminate = false;
                    } else {
                        catCheckbox.checked = false;
                        catCheckbox.indeterminate = true;
                    }
                }
                // Only listen for changes within this block
                const block = catCheckbox.closest('.category-block');
                if (block) {
                    block.addEventListener('change', function(e) {
                        if (!e.target.classList.contains('category-checkbox')) syncCatCheckbox();
                    });
                }
                syncCatCheckboxFns[category] = syncCatCheckbox;
                syncCatCheckbox();
            }
            // Dynamically set up batch toggles for all categories
            Object.keys(symbolCategories).forEach(cat => {
                if (catCheckboxes[cat]) {
                    setupCategoryBatchToggle(cat, symbolCategories[cat], catCheckboxes[cat]);
                }
            });

            function getSelectedSymbols() {
                // All checked series checkboxes in the flat structure
                return Array.from(document.querySelectorAll('.series-categories > label > input[type=checkbox]:checked')).map(cb => cb.value);
            }

            let currentMode = 'raw';
            window.smoothLineEnabled = true;
            function getModeStates() {
                return {
                    normalized: currentMode === 'normalized',
                    indexed: currentMode === 'indexed'
                };
            }
            let selectedSyms = getSelectedSymbols();
            let chartOption = prepareEChartsOption(
                selectedSyms,
                data,
                getModeStates().normalized,
                getModeStates().indexed
            );
            const casinoChart = echarts.init(document.getElementById('casinoChart'));
            // Smooth button logic
            const smoothBtn = document.getElementById('smooth-btn');
            function updateSmoothBtn() {
                if (window.smoothLineEnabled) {
                    smoothBtn.classList.add('active');
                } else {
                    smoothBtn.classList.remove('active');
                }
            }
            smoothBtn.addEventListener('click', function() {
                window.smoothLineEnabled = !window.smoothLineEnabled;
                updateSmoothBtn();
                updateChart();
            });
            updateSmoothBtn();
            casinoChart.setOption(chartOption);
            // Responsive: resize chart on window resize
            window.addEventListener('resize', () => {
                casinoChart.resize();
            });
           // Force repaint after font load to fix font fallback issue and reveal chart
            setTimeout(() => {
                casinoChart.resize();
                document.getElementById('chart-container').style.visibility = 'visible';
            }, 0);

            function updateCheckboxColors() {
                const selected = getSelectedSymbols();
                selected.forEach((sym, idx) => {
                    const label = document.querySelector('label[data-symbol="' + sym + '"]');
                    if (label) {
                        const hex = BASE_COLORS[idx % BASE_COLORS.length].replace('#','');
                        const r = parseInt(hex.substring(0,2),16);
                        const g = parseInt(hex.substring(2,4),16);
                        const b = parseInt(hex.substring(4,6),16);
                        const rgba = `rgba(${r},${g},${b},0.8)`;
                        label.style.background = rgba;
                        label.style.borderColor = rgba;
                        const luminance = (0.299*r + 0.587*g + 0.114*b) / 255;
                        label.style.color = luminance > 0.6 ? '#181c24' : '#fff';
                        label.style.boxShadow = '0 2px 8px 0 rgba(0,0,0,0.18)';
                    }
                });
                // Unselect all other symbols
                // Get all symbols from all categories
                let allSyms = [];
                Object.values(symbolCategories).forEach(arr => { allSyms = allSyms.concat(arr); });
                allSyms.forEach(sym => {
                    if (!selected.includes(sym)) {
                        const label = document.querySelector('label[data-symbol="' + sym + '"]');
                        if (label) {
                            label.style.background = '';
                            label.style.borderColor = '';
                            label.style.color = '#b0b4c1';
                            label.style.boxShadow = '';
                        }
                    }
                });
            }
            function getCurrentWindowRange() {
                // Get current dataZoom window (returns [startIdx, endIdx])
                const option = casinoChart.getOption();
                const dz = option.dataZoom && option.dataZoom[0];
                const total = option.xAxis[0].data.length;
                const start = dz ? Math.round((dz.start / 100) * (total - 1)) : 0;
                const end = dz ? Math.round((dz.end / 100) * (total - 1)) : total - 1;
                return [start, end];
            }
            function updateChart() {
                const selected = getSelectedSymbols();
                const { normalized, indexed } = getModeStates();
                // Always get the current window range for all modes
                let windowRange = getCurrentWindowRange();
                const newOption = prepareEChartsOption(selected, data, normalized, !normalized && indexed, { windowRange });
                // Always preserve the current dataZoom window
                const option = casinoChart.getOption();
                if (option.dataZoom && option.dataZoom[0]) {
                    newOption.dataZoom[0].start = option.dataZoom[0].start;
                    newOption.dataZoom[0].end = option.dataZoom[0].end;
                }
                // Hide tooltip before updating chart to avoid DOM errors
                try { casinoChart.dispatchAction({ type: 'hideTip' }); } catch (e) {}
                casinoChart.clear();
                casinoChart.setOption(newOption, { notMerge: true, replaceMerge: ['series'] });
                updateCheckboxColors();
                // Sync all category checkboxes after chart update
                Object.values(syncCatCheckboxFns).forEach(fn => fn());
            }
            // Listen for zoom events to update rebasing
            let chartReady = false;
            casinoChart.on('dataZoom', function() {
                if (chartReady) updateChart();
            });
            chartReady = true;
            // Initial color sync
            updateCheckboxColors();
            // All change events now handled by the category-block listeners
            // Mode button logic
            const modeBtns = document.querySelectorAll('.mode-btn[data-mode]');
            function updateModeBtns() {
                modeBtns.forEach(btn => {
                    if (btn.getAttribute('data-mode') === currentMode) {
                        btn.style.background = '#00bcd4';
                        btn.style.color = '#181c24';
                        btn.style.borderColor = '#00bcd4';
                    } else {
                        btn.style.background = '#232837';
                        btn.style.color = '#fff';
                        btn.style.borderColor = '#2e3448';
                    }
                });
            }
            modeBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    currentMode = btn.getAttribute('data-mode');
                    updateModeBtns();
                    updateChart();
                });
            });
            updateModeBtns();
        }
    </script>
</body>
</html>
