<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GalaxyProspect Dashboard</title>
    <script src="./echarts.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
        .main-window {
            margin-left: 68px;
            height: 100vh;
            width: calc(100vw - 68px);
            position: relative;
            overflow: hidden;
        }
        .checkbox-group label {
            display: block;
            margin-bottom: 0.5em;
            cursor: pointer;
            font-size: 1em;
        }
        .checkbox-group input[type=checkbox] {
            appearance: none;
            -webkit-appearance: none;
            width: 1.15em;
            height: 1.15em;
            border: 2.2px solid #b0b4c1;
            border-radius: 5px;
            background: #232837;
            outline: none;
            cursor: pointer;
            position: relative;
            margin-right: 0.4em;
            vertical-align: middle;
            transition: border-color 0.18s, background 0.18s, box-shadow 0.18s;
        }
        .floating-panel {
            display: none;
            position: absolute;
            min-width: 260px;
            max-width: 340px;
            z-index: 100;
        }
        .floating-panel.active {
            display: block;
        }
    body {
            font-family: 'Inter', Arial, sans-serif;
            font-size: 16px;
            margin: 0;
            background: #181c24;
            color: #f5f6fa;
            min-height: 100vh;
        }
        .checkbox-group {
            background: #232837;
            border-radius: 14px;
            padding: 1.1em 1.5em 1.1em 1.2em;
            margin-bottom: 0.5em;
            box-shadow: 0 4px 24px 0 rgba(0,0,0,0.18);
            /* restore static layout for content formatting */
        }
        .sidebar {
        width: 68px;
            background: #181c24;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 2em;
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            z-index: 10;
            box-shadow: 2px 0 16px 0 rgba(0,0,0,0.12);
        }
        .sidebar-icon {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.45em;
            background: linear-gradient(135deg, #232837 70%, #222c38 100%);
            border-radius: 12px;
            color: #888a92; /* grey color for icons */
            cursor: pointer;
            transition: background 0.18s, color 0.18s, box-shadow 0.18s, transform 0.18s;
            box-shadow: 0 2px 8px 0 rgba(0,188,212,0.08);
            position: relative;
            margin-bottom: 0.5em;
            border: 1.5px solid #232837;
        }
        .sidebar-icon svg {
            width: 1.5em;
            height: 1.5em;
            display: block;
        }
        .sidebar-icon:hover, .sidebar-icon.active {
            background: linear-gradient(135deg, #e0e0e0 80%, #bdbdbd 100%);
            color: #888a92;
            box-shadow: 0 2px 12px 0 rgba(136,138,146,0.13);
            border-color: #888a92;
            transform: scale(1.07) rotate(-12deg); /* rotate on hover */
        }
        .checkbox-group input[type=checkbox]:hover, .checkbox-group input[type=checkbox]:focus {
            box-shadow: 0 0 0 3px rgba(0,188,212,0.18);
            border-color: currentColor;
        }
        .checkbox-group input[type=checkbox]:checked {
            border-color: currentColor;
            background: currentColor;
        }
        .checkbox-group input[type=checkbox]:checked::after {
            content: '';
            position: absolute;
            left: 0.36em;
            top: 0.13em;
            width: 0.35em;
            height: 0.7em;
            border-right: 3px solid #fff;
            border-bottom: 3px solid #fff;
            border-radius: 1px;
            transform: scale(1) rotate(45deg);
            opacity: 1;
            transition: all 0.18s cubic-bezier(.4,2,.6,1);
            background: none;
            z-index: 2;
        }
        .checkbox-group input[type=checkbox]::after {
            content: '';
            position: absolute;
            left: 0.36em;
            top: 0.13em;
            width: 0.35em;
            height: 0.7em;
            border-right: 3px solid currentColor;
            border-bottom: 3px solid currentColor;
            border-radius: 1px;
            transform: scale(0.2) rotate(45deg);
            opacity: 0;
            transition: all 0.18s cubic-bezier(.4,2,.6,1);
            background: none;
            z-index: 2;
        }
        .normalize-label {
            color: #b0b4c1;
            font-size: 1em;
            font-weight: 500;
            margin-left: 0.5em;
            cursor: pointer;
        }
        #chart-container {
            width: 100%;
            height: 100%;
            margin: 0;
            border-radius: 0;
            background: #181c24;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        /* ECharts dataZoom slider interactivity fix */
        .echarts, .echarts-container, .echarts-for-react {
            position: relative !important;
            z-index: 2 !important;
            pointer-events: auto !important;
        }
        .ec-extension-datazoom-slider, .echarts-datazoom {
            z-index: 1000 !important;
            pointer-events: auto !important;
        }
        /* Make ECharts dataZoom slider always interactive */
        .echarts { position: relative; z-index: 1; }
        .echarts datazoom, .echarts .ec-extension-datazoom-slider {
            z-index: 10 !important;
            pointer-events: auto !important;
        }
        #casinoChart {
            width: 100% !important;
            height: 100% !important;
            min-height: 0;
            min-width: 0;
            display: block;
        }
        @media (max-width: 900px) {
            .dashboard-card { padding: 1.2rem 0.5rem 1.2rem 0.5rem; }
            h2 { font-size: 1.2rem; }
            .controls { gap: 1rem; flex-direction: column; }
            .checkbox-group { min-width: 0; }
        }
    </style>
</head>
<body>
        <div class="layout">
            <aside class="sidebar">
                <!-- View Mode Icon -->
                <div class="sidebar-icon" data-panel="mode" title="Chart Mode" style="margin-bottom:1.1em;">
                    <svg viewBox="0 0 32 32" fill="none">
                        <circle cx="16" cy="16" r="13" stroke="currentColor" stroke-width="3" fill="none"/>
                        <g>
                            <rect x="8" y="10" width="4" height="12" rx="1.2" fill="currentColor" opacity="0.7"/>
                            <rect x="14" y="6" width="4" height="16" rx="1.2" fill="currentColor"/>
                            <rect x="20" y="14" width="4" height="8" rx="1.2" fill="currentColor" opacity="0.7"/>
                        </g>
                    </svg>
                </div>
                <!-- Series Checkboxes Icon -->
                <div class="sidebar-icon" data-panel="series" title="Series Selection">
                    <svg viewBox="0 0 32 32" fill="none">
                        <rect x="3" y="13" width="6" height="16" rx="2" fill="currentColor"/>
                        <rect x="13" y="7" width="6" height="22" rx="2" fill="currentColor"/>
                        <rect x="23" y="17" width="6" height="12" rx="2" fill="currentColor"/>
                    </svg>
                </div>
            </aside>
            <div class="main-window">
                <div id="chart-container"><div id="casinoChart"></div></div>
            </div>
            <div class="floating-panel" id="panel-mode">
                <div class="checkbox-group" style="padding:1.1em 1.5em 1.1em 1.2em; background:#232837; border-radius:14px; box-shadow:0 4px 24px 0 rgba(0,0,0,0.18);">
                    <label style="font-weight:600;display:block;margin-bottom:0.7em;font-size:1em;">Chart Mode:</label>
                    <div id="mode-options" style="display:flex;flex-direction:column;gap:0.7em;width:100%;">
                        <button class="mode-btn" data-mode="raw" style="width:100%;margin-bottom:0.3em;padding:0.4em 0;border-radius:6px;border:1.2px solid #2e3448;background:#232837;color:#fff;font-size:0.95em;font-weight:500;cursor:pointer;transition:background 0.15s,border-color 0.15s;text-align:center;">Raw</button>
                        <button class="mode-btn" data-mode="normalized" style="width:100%;margin-bottom:0.3em;padding:0.4em 0;border-radius:6px;border:1.2px solid #2e3448;background:#232837;color:#fff;font-size:0.95em;font-weight:500;cursor:pointer;transition:background 0.15s,border-color 0.15s;text-align:center;">Normalized</button>
                        <button class="mode-btn" data-mode="indexed" style="width:100%;margin-bottom:0;padding:0.4em 0;border-radius:6px;border:1.2px solid #2e3448;background:#232837;color:#fff;font-size:0.95em;font-weight:500;cursor:pointer;transition:background 0.15s,border-color 0.15s;text-align:center;">Indexed</button>
                    </div>
                </div>
            </div>
            <div class="floating-panel" id="panel-series" style="padding: 1.2em 1.5em; background: #232837; border-radius: 18px; box-shadow: 0 4px 24px 0 rgba(0,0,0,0.18); min-width: 600px; max-width: 900px;">
                <div id="series-categories" style="display: flex; flex-wrap: wrap; gap: 2em; align-items: flex-start; justify-content: flex-start;">
                    <div class="checkbox-group" id="company-checkboxes" style="min-width: 180px; flex: 1 1 180px;"></div>
                    <div class="checkbox-group" id="index-checkboxes" style="min-width: 180px; flex: 1 1 180px;"></div>
                    <div class="checkbox-group" id="fx-checkboxes" style="min-width: 180px; flex: 1 1 180px;"></div>
                    <div class="checkbox-group" id="commodity-checkboxes" style="min-width: 180px; flex: 1 1 180px;"></div>
                    <div class="checkbox-group" id="macro-checkboxes" style="min-width: 180px; flex: 1 1 180px;"></div>
                </div>
            </div>
        </div>

    <script>

        // Sidebar panel hover logic for two icons
        document.addEventListener('DOMContentLoaded', function() {
            const icons = [
                { icon: document.querySelector('.sidebar-icon[data-panel="mode"]'), panel: document.getElementById('panel-mode') },
                { icon: document.querySelector('.sidebar-icon[data-panel="series"]'), panel: document.getElementById('panel-series') }
            ];
            let panelTimeout = null;
            icons.forEach(({icon, panel}) => {
                icon.addEventListener('mouseenter', (e) => {
                    document.querySelectorAll('.floating-panel').forEach(p => p.classList.remove('active'));
                    if (panel) {
                        const rect = icon.getBoundingClientRect();
                        const sidebarWidth = icon.parentElement.offsetWidth;
                        panel.style.display = 'block';
                        const panelHeight = panel.offsetHeight || 480;
                        panel.style.display = '';
                        let top = rect.top + window.scrollY + rect.height/2 - panelHeight/2;
                        top = Math.max(16, Math.min(top, window.innerHeight - panelHeight - 16));
                        panel.style.left = sidebarWidth + 'px';
                        panel.style.top = top + 'px';
                        panel.classList.add('active');
                        icon.classList.add('active');
                    }
                });
                icon.addEventListener('mouseleave', () => {
                    panelTimeout = setTimeout(() => {
                        if (panel) panel.classList.remove('active');
                        icon.classList.remove('active');
                    }, 200);
                });
                if (panel) {
                    panel.addEventListener('mouseenter', () => {
                        clearTimeout(panelTimeout);
                        panel.classList.add('active');
                        icon.classList.add('active');
                    });
                    panel.addEventListener('mouseleave', () => {
                        panel.classList.remove('active');
                        icon.classList.remove('active');
                    });
                }
            });
        });

        // Load config.json for symbol metadata and categories
    let configData = { symbols: [] };
        let symbolNames = {};
        let symbolCategories = { company: [], index: [], fx: [], commodity: [], macro: [] };
        function categorizeSymbols() {
            symbolCategories = { company: [], index: [], fx: [], commodity: [], macro: [] };
            (configData.symbols || []).forEach(item => {
                symbolNames[item.symbol_name] = item.desc;
                // Categorize based on symbol_name pattern or desc
                if (item.server === 'YF') {
                    if (/\.HK$/.test(item.symbol_name)) symbolCategories.company.push(item.symbol_name);
                    else if (/\^HSI|\.SS$|\.SZ$/.test(item.symbol_name)) symbolCategories.index.push(item.symbol_name);
                    else if (/=X$|NYB$/.test(item.symbol_name)) symbolCategories.fx.push(item.symbol_name);
                    else if (/=F$/.test(item.symbol_name)) symbolCategories.commodity.push(item.symbol_name);
                } else if (item.server === 'FRED') {
                    symbolCategories.macro.push(item.symbol_name);
                }
            });
        }

        async function fetchConfig() {
            const res = await fetch('config.json');
            configData = await res.json();
            categorizeSymbols();
        }

        async function fetchData() {
            // Fetch unified data.json only
            const res = await fetch('/api/data');
            return await res.json();
        }

        function getColor(idx) {
            // High-contrast, colorblind-friendly palette for dark backgrounds
            const colors = [
                '#FFD600', // Galaxy - Vivid Yellow
                '#00E676', // SJM - Bright Green
                '#FF1744', // Wynn - Vivid Red
                '#2979FF', // Sands - Bright Blue
                '#F500A3', // MGM - Magenta
                '#FF9100', // Melco - Orange
                '#00B8D4', // Hang Seng - Cyan
                '#C51162', // Shanghai - Deep Pink
                '#AEEA00'  // Shenzhen - Lime
            ];
            return colors[idx % colors.length];
        }

    function prepareEChartsOption(selectedSymbols, data, normalized, indexed, opts = {}) {
            // Always use the full union of all dates from all symbols for a stable x-axis
            // Generate a complete calendar date range from min to max date in the data
            let minDate = null, maxDate = null;
            Object.values(data).forEach(symbolData => {
                Object.keys(symbolData).forEach(date => {
                    const d = new Date(date);
                    if (!minDate || d < minDate) minDate = d;
                    if (!maxDate || d > maxDate) maxDate = d;
                });
            });
            function formatDate(d) {
                const m = (d.getMonth() + 1).toString().padStart(2, '0');
                const day = d.getDate().toString().padStart(2, '0');
                return `${d.getFullYear()}-${m}-${day}`;
            }
            const sortedDates = [];
            if (minDate && maxDate) {
                for (let d = new Date(minDate); d <= maxDate; d.setDate(d.getDate() + 1)) {
                    sortedDates.push(formatDate(d));
                }
            }
            // Compute y-axis min/max based on visible (non-null) values in the current window for selected series
            let yMin = undefined, yMax = undefined;
            if (normalized) {
                yMin = 0;
                yMax = 1.05;
            } else if (indexed) {
                yMin = 0;
                yMax = undefined;
            } else if (selectedSymbols.length > 0) {
                let windowRange = opts.windowRange || [0, sortedDates.length - 1];
                let allVisible = [];
                selectedSymbols.filter(symbol => data[symbol]).forEach(symbol => {
                    const entries = Object.entries(data[symbol]);
                    const dateToAdjClose = Object.fromEntries(entries.map(([date, v]) => [date, v['Adj Close'] ?? null]));
                    let values = sortedDates.map(date => dateToAdjClose[date] ?? null);
                    // Only consider values in the current window
                    values = values.slice(windowRange[0], windowRange[1] + 1);
                    allVisible.push(...values.filter(v => v != null && isFinite(v)));
                });
                if (allVisible.length > 0) {
                    yMin = Math.min(...allVisible);
                    yMax = Math.max(...allVisible);
                    if (yMin === yMax) {
                        // Add a small buffer if all values are the same
                        yMin = yMin * 0.98;
                        yMax = yMax * 1.02;
                    }
                }
            }
            // Prepare series for each symbol
            const series = selectedSymbols.map((symbol, idx) => {
                if (!data[symbol]) return null; // skip if data missing
                const entries = Object.entries(data[symbol]);
                // Only use 'Adj Close', never fallback to 'Close'
                const dateToAdjClose = Object.fromEntries(entries.map(([date, v]) => [date, v['Adj Close'] ?? null]));
                let values = sortedDates.map(date => dateToAdjClose[date] ?? null);
                let actualValues = values.slice();
                if (normalized && values.filter(v => v != null).length > 0) {
                    // Min-max normalization: (value - min) / (max - min) within zoom window
                    let min, max, range;
                    if (opts.windowRange) {
                        const [start, end] = opts.windowRange;
                        const windowVals = values.slice(start, end + 1).filter(v => v != null);
                        min = windowVals.length ? Math.min(...windowVals) : 0;
                        max = windowVals.length ? Math.max(...windowVals) : 0;
                        range = max - min;
                        // Store actual values for tooltip
                        actualValues = values.slice();
                        values = values.map((v, i) => {
                            if (v == null) return null;
                            if (i < start || i > end) return null;
                            return range === 0 ? 0 : (v - min) / range;
                        });
                    } else {
                        const valid = values.filter(v => v != null);
                        min = Math.min(...valid);
                        max = Math.max(...valid);
                        range = max - min;
                        // Store actual values for tooltip
                        actualValues = values.slice();
                        values = values.map(v => v == null ? null : (range === 0 ? 0 : (v - min) / range));
                    }
                } else if (indexed && values.filter(v => v != null).length > 0 && opts.windowRange) {
                    // Indexed mode: divide by first non-null value in the current window
                    const [start, end] = opts.windowRange;
                    const windowVals = values.slice(start, end + 1);
                    const firstIdxInWindow = windowVals.findIndex(v => v != null);
                    const base = firstIdxInWindow !== -1 ? windowVals[firstIdxInWindow] : null;
                    // Store actual values for tooltip
                    actualValues = values.slice();
                    values = values.map((v, i) => {
                        if (v == null) return null;
                        if (base == null) return null;
                        return i >= start && i <= end ? v / base : null;
                    });
                }
                return {
                    name: symbol + ' (' + (symbolNames[symbol] || symbol) + ') Adj Close',
                    type: 'line',
                    data: values,
                    yAxisIndex: 0,
                    showSymbol: false,
                    connectNulls: true,
                    lineStyle: { width: 2, color: getColor(idx) },
                    itemStyle: { color: getColor(idx) },
                    emphasis: { focus: 'series' },
                    tooltip: {
                        valueFormatter: function (value, i) {
                            if ((normalized || indexed) && typeof value === 'number' && typeof actualValues[i] === 'number') {
                                return value.toFixed(3) + ' (actual: ' + actualValues[i].toFixed(2) + ')';
                            } else if (typeof value === 'number') {
                                return value.toFixed(2);
                            } else {
                                return 'N/A';
                            }
                        }
                    }
                };
            }).filter(Boolean);
            // Show volume bars for any single selected symbol (company or index) if volume data exists
            if (selectedSymbols.length === 1) {
                const symbol = selectedSymbols[0];
                const entries = Object.entries(data[symbol]);
                // Try both 'Volume' and 'volume' keys for robustness
                const dateToVolume = Object.fromEntries(entries.map(([date, v]) => [date, v['Volume'] ?? v['volume'] ?? null]));
                // Debug: log volume data for selected symbol
                // Only add if there is at least some volume data
                if (Object.values(dateToVolume).some(v => v != null)) {
                    // Outlier filter: if a value is >10x the previous max, treat as null
                    let prevMax = null;
                    const filteredVolumeArray = sortedDates.map(date => {
                        const v = dateToVolume[date] ?? null;
                        if (v == null) return null;
                        if (prevMax === null) {
                            prevMax = v;
                            return v;
                        }
                        if (v > prevMax * 10) {
                            return null;
                        }
                        if (v > prevMax) prevMax = v;
                        return v;
                    });
                    if (['^HSI','000001.SS','399001.SZ'].includes(symbol)) {
                        console.log('Filtered volume array for', symbol, filteredVolumeArray);
                    }
                    series.push({
                        name: symbol + ' (' + (symbolNames[symbol] || symbol) + ') Volume',
                        type: 'bar',
                        data: filteredVolumeArray,
                        yAxisIndex: 1,
                        itemStyle: {
                            color: (symbol === '^HSI') ? '#00B8D4' : (symbol === '000001.SS') ? '#C51162' : (symbol === '399001.SZ') ? '#AEEA00' : '#FFD600',
                            opacity: 0.25
                        },
                        emphasis: { focus: 'series' },
                        tooltip: { valueFormatter: v => v != null ? v.toLocaleString() : 'N/A' }
                    });
                }
            }
            // Always use linear scale for volume, and set min/max dynamically for visible volume data
            let volumeMin = null, volumeMax = null;
            if (selectedSymbols.length === 1) {
                const symbol = selectedSymbols[0];
                const entries = Object.entries(data[symbol]);
                const volumes = entries.map(([date, v]) => v['Volume'] ?? v['volume']).filter(v => v != null);
                if (volumes.length > 0) {
                    volumeMin = Math.min(...volumes);
                    volumeMax = Math.max(...volumes);
                }
            }
            // Default to last 36 months (about 756 trading days)
            const defaultMonths = 36;
            const defaultDays = defaultMonths * 21; // ~21 trading days per month
            const defaultWindow = sortedDates.length > defaultDays ? Math.round((sortedDates.length - defaultDays) / sortedDates.length * 100) : 0;
            return {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'cross',
                        crossStyle: {
                            color: '#00bcd4',
                            width: 1.5
                        },
                        label: {
                            backgroundColor: '#232837',
                            color: '#fff',
                            borderColor: '#00bcd4',
                            borderWidth: 1,
                            fontWeight: 'bold',
                            fontSize: 13,
                            padding: [6, 12],
                            shadowColor: '#000',
                            shadowBlur: 6
                        }
                    },
                    backgroundColor: '#232837',
                    borderColor: '#fff',
                    textStyle: { color: '#fff' }
                },
                legend: { show: false },
                grid: { left: 60, right: 60, top: 85, bottom: 90 },
                dataZoom: [
                    {
                        type: 'slider',
                        show: true,
                        xAxisIndex: 0,
                        // Show only the most recent 36 months (about 756 trading days) by default
                        start: defaultWindow,
                        end: 100,
                        height: 22,
                        bottom: null,
                        top: 0, // Place slider at the very top of the chart area
                        backgroundColor: '#232837',
                        borderColor: '#333',
                        fillerColor: 'rgba(0,188,212,0.18)',
                        handleIcon: 'M8.7,11.3v-8.6h2.6v8.6H8.7z',
                        handleSize: '120%',
                        moveHandleSize: '100%',
                        showDetail: true,
                        handleStyle: { color: '#00bcd4' },
                        textStyle: { color: '#fff' }
                    }
                ],
                xAxis: {
                    type: 'category',
                    data: sortedDates,
                    axisLabel: {
                        rotate: 45,
                        color: '#fff',
                        fontWeight: 500,
                        interval: 'auto',
                    },
                    axisLine: { lineStyle: { color: '#fff' } }
                },
                yAxis: [
                    {
                        type: 'value',
                        name: normalized ? 'Normalized Adj Close' : 'Adj Close',
                        position: 'left',
                        axisLine: { show: true, lineStyle: { color: '#fff' } },
                        axisLabel: { formatter: v => normalized ? v.toFixed(2) : v, color: '#fff', fontWeight: 500 },
                        nameTextStyle: { color: '#fff', fontWeight: 600 },
                        splitLine: { lineStyle: { color: '#333' } },
                        min: yMin,
                        max: yMax
                    },
                    {
                        type: 'value',
                        name: 'Volume',
                        position: 'right',
                        axisLine: { show: true, lineStyle: { color: '#fff' } },
                        axisLabel: { formatter: v => v != null ? v.toLocaleString() : '', color: '#fff', fontWeight: 500 },
                        nameTextStyle: { color: '#fff', fontWeight: 600 },
                        splitLine: { show: false },
                        min: 0,
                        max: undefined
                    }
                ],
                series: series.map(s => s.type === 'bar' ? { ...s, barMinWidth: 3 } : s)
            };
        }

        async function main() {
            await fetchConfig();
            const data = await fetchData();
            const symbols = Object.keys(data);

            // Use config-driven categories
            const companySymbols = symbolCategories.company.filter(sym => data[sym]);
            const indexSymbols = symbolCategories.index.filter(sym => data[sym]);
            const fxSymbols = symbolCategories.fx.filter(sym => data[sym]);
            const commoditySymbols = symbolCategories.commodity.filter(sym => data[sym]);
            const macroSymbols = symbolCategories.macro.filter(sym => data[sym]);

            // Company checkboxes
            const companyDiv = document.getElementById('company-checkboxes');
            companyDiv.innerHTML = '<label class="category-label" style="font-weight:600;cursor:pointer;"><input type="checkbox" class="category-checkbox" data-category="company" style="margin-right:0.5em;">Companies:</label> ';
            companySymbols.forEach((sym, idx) => {
                const label = document.createElement('label');
                label.style.marginRight = '1em';
                label.setAttribute('data-symbol', sym);
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = sym;
                cb.checked = (sym === companySymbols[0]);
                label.appendChild(cb);
                label.appendChild(document.createTextNode(' ' + sym + ' (' + (symbolNames[sym] || sym) + ')'));
                companyDiv.appendChild(label);
            });

            // Index checkboxes
            const indexDiv = document.getElementById('index-checkboxes');
            indexDiv.innerHTML = '<label class="category-label" style="font-weight:600;cursor:pointer;"><input type="checkbox" class="category-checkbox" data-category="index" style="margin-right:0.5em;">Market Indexes:</label> ';
            indexSymbols.forEach((sym, idx) => {
                const label = document.createElement('label');
                label.style.marginRight = '1em';
                label.setAttribute('data-symbol', sym);
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = sym;
                cb.checked = false;
                label.appendChild(cb);
                label.appendChild(document.createTextNode(' ' + sym + ' (' + (symbolNames[sym] || sym) + ')'));
                indexDiv.appendChild(label);
            });

            // FX checkboxes
            let fxDiv = document.getElementById('fx-checkboxes');
            if (!fxDiv) {
                fxDiv = document.createElement('div');
                fxDiv.className = 'checkbox-group';
                fxDiv.id = 'fx-checkboxes';
                indexDiv.parentNode.insertBefore(fxDiv, indexDiv.nextSibling);
            }
            fxDiv.innerHTML = '<label class="category-label" style="font-weight:600;cursor:pointer;"><input type="checkbox" class="category-checkbox" data-category="fx" style="margin-right:0.5em;">FX:</label> ';
            fxSymbols.forEach((sym, idx) => {
                const label = document.createElement('label');
                label.style.marginRight = '1em';
                label.setAttribute('data-symbol', sym);
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = sym;
                cb.checked = false;
                label.appendChild(cb);
                label.appendChild(document.createTextNode(' ' + sym + ' (' + (symbolNames[sym] || sym) + ')'));
                fxDiv.appendChild(label);
            });

            // Commodity checkboxes
            let commodityDiv = document.getElementById('commodity-checkboxes');
            if (!commodityDiv) {
                commodityDiv = document.createElement('div');
                commodityDiv.className = 'checkbox-group';
                commodityDiv.id = 'commodity-checkboxes';
                fxDiv.parentNode.insertBefore(commodityDiv, fxDiv.nextSibling);
            }
            commodityDiv.innerHTML = '<label class="category-label" style="font-weight:600;cursor:pointer;"><input type="checkbox" class="category-checkbox" data-category="commodity" style="margin-right:0.5em;">Commodities:</label> ';
            commoditySymbols.forEach((sym, idx) => {
                const label = document.createElement('label');
                label.style.marginRight = '1em';
                label.setAttribute('data-symbol', sym);
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = sym;
                cb.checked = false;
                label.appendChild(cb);
                label.appendChild(document.createTextNode(' ' + sym + ' (' + (symbolNames[sym] || sym) + ')'));
                commodityDiv.appendChild(label);
            });

            // Macro checkboxes
            let macroDiv = document.getElementById('macro-checkboxes');
            if (!macroDiv) {
                macroDiv = document.createElement('div');
                macroDiv.className = 'checkbox-group';
                macroDiv.id = 'macro-checkboxes';
                commodityDiv.parentNode.insertBefore(macroDiv, commodityDiv.nextSibling);
            }
            macroDiv.innerHTML = '<label class="category-label" style="font-weight:600;cursor:pointer;"><input type="checkbox" class="category-checkbox" data-category="macro" style="margin-right:0.5em;">Macro:</label> ';
            macroSymbols.forEach((sym, idx) => {
                const label = document.createElement('label');
                label.style.marginRight = '1em';
                label.setAttribute('data-symbol', sym);
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = sym;
                cb.checked = false;
                label.appendChild(cb);
                label.appendChild(document.createTextNode(' ' + sym + ' (' + (symbolNames[sym] || sym) + ')'));
                macroDiv.appendChild(label);
            });

            // Helper: batch check/uncheck children when category label is toggled
            function setupCategoryBatchToggle(category, symbols, div) {
                const catCheckbox = div.querySelector('input.category-checkbox[data-category="' + category + '"]');
                catCheckbox.addEventListener('change', function() {
                    const checked = catCheckbox.checked;
                    symbols.forEach(sym => {
                        if (!data[sym]) return;
                        const cb = div.querySelector('input[type=checkbox][value="' + sym + '"]');
                        if (cb) cb.checked = checked;
                    });
                    updateChart();
                });
                function syncCatCheckbox() {
                    const cbs = symbols.map(sym => div.querySelector('input[type=checkbox][value="' + sym + '"]')).filter(Boolean);
                    const checkedCount = cbs.filter(cb => cb.checked).length;
                    if (checkedCount === cbs.length && cbs.length > 0) {
                        catCheckbox.checked = true;
                        catCheckbox.indeterminate = false;
                    } else if (checkedCount === 0) {
                        catCheckbox.checked = false;
                        catCheckbox.indeterminate = false;
                    } else {
                        catCheckbox.checked = false;
                        catCheckbox.indeterminate = true;
                    }
                }
                div.addEventListener('change', function(e) {
                    if (!e.target.classList.contains('category-checkbox')) syncCatCheckbox();
                });
                syncCatCheckbox();
            }
            setupCategoryBatchToggle('company', companySymbols, companyDiv);
            setupCategoryBatchToggle('index', indexSymbols, indexDiv);
            setupCategoryBatchToggle('fx', fxSymbols, fxDiv);
            setupCategoryBatchToggle('commodity', commoditySymbols, commodityDiv);
            setupCategoryBatchToggle('macro', macroSymbols, macroDiv);

            function getSelectedSymbols() {
                const companyDiv = document.getElementById('company-checkboxes');
                const indexDiv = document.getElementById('index-checkboxes');
                const fxDiv = document.getElementById('fx-checkboxes');
                const commodityDiv = document.getElementById('commodity-checkboxes');
                const macroDiv = document.getElementById('macro-checkboxes');
                const companyChecked = Array.from(companyDiv.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
                const indexChecked = Array.from(indexDiv.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
                const fxChecked = Array.from(fxDiv.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
                const commodityChecked = Array.from(commodityDiv.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
                const macroChecked = Array.from(macroDiv.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
                return [...companyChecked, ...indexChecked, ...fxChecked, ...commodityChecked, ...macroChecked];
            }

            let currentMode = 'raw';
            function getModeStates() {
                return {
                    normalized: currentMode === 'normalized',
                    indexed: currentMode === 'indexed'
                };
            }
            let chartOption = prepareEChartsOption(
                getSelectedSymbols(),
                data,
                getModeStates().normalized,
                getModeStates().indexed
            );
            const casinoChart = echarts.init(document.getElementById('casinoChart'));
            casinoChart.setOption(chartOption);
            // Responsive: resize chart on window resize
            window.addEventListener('resize', () => {
                casinoChart.resize();
            });

            function updateCheckboxColors() {
                // Get current selected symbols in order
                const selected = getSelectedSymbols();
                // For each selected symbol, set its label color to the palette color for its current index
                selected.forEach((sym, idx) => {
                    const label = document.querySelector('label[data-symbol="' + sym + '"]');
                    if (label) label.style.color = getColor(idx);
                });
                // For unselected, set color to #b0b4c1 (default)
                [...companySymbols, ...indexSymbols, ...fxSymbols, ...commoditySymbols, ...macroSymbols].forEach(sym => {
                    if (!selected.includes(sym)) {
                        const label = document.querySelector('label[data-symbol="' + sym + '"]');
                        if (label) label.style.color = '#b0b4c1';
                    }
                });
            }
            function getCurrentWindowRange() {
                // Get current dataZoom window (returns [startIdx, endIdx])
                const option = casinoChart.getOption();
                const dz = option.dataZoom && option.dataZoom[0];
                const total = option.xAxis[0].data.length;
                const start = dz ? Math.round((dz.start / 100) * (total - 1)) : 0;
                const end = dz ? Math.round((dz.end / 100) * (total - 1)) : total - 1;
                return [start, end];
            }
            function updateChart() {
                const selected = getSelectedSymbols();
                const { normalized, indexed } = getModeStates();
                // Always get the current window range for indexed or normalized mode
                let windowRange = undefined;
                if (indexed || normalized) {
                    windowRange = getCurrentWindowRange();
                }
                const newOption = prepareEChartsOption(selected, data, normalized, !normalized && indexed, { windowRange });
                // Always preserve the current dataZoom window
                const option = casinoChart.getOption();
                if (option.dataZoom && option.dataZoom[0]) {
                    newOption.dataZoom[0].start = option.dataZoom[0].start;
                    newOption.dataZoom[0].end = option.dataZoom[0].end;
                }
                // Hide tooltip before updating chart to avoid DOM errors
                try { casinoChart.dispatchAction({ type: 'hideTip' }); } catch (e) {}
                casinoChart.clear();
                casinoChart.setOption(newOption, { notMerge: true, replaceMerge: ['series'] });
                updateCheckboxColors();
            }
            // Listen for zoom events to update rebasing
            let chartReady = false;
            casinoChart.on('dataZoom', function() {
                if (chartReady) updateChart();
            });
            chartReady = true;
            // Initial color sync
            updateCheckboxColors();
            companyDiv.addEventListener('change', updateChart);
            indexDiv.addEventListener('change', updateChart);
            if (fxDiv) fxDiv.addEventListener('change', updateChart);
            if (commodityDiv) commodityDiv.addEventListener('change', updateChart);
            if (macroDiv) macroDiv.addEventListener('change', updateChart);
            // Mode button logic
            const modeBtns = document.querySelectorAll('.mode-btn');
            function updateModeBtns() {
                modeBtns.forEach(btn => {
                    if (btn.getAttribute('data-mode') === currentMode) {
                        btn.style.background = '#00bcd4';
                        btn.style.color = '#181c24';
                        btn.style.borderColor = '#00bcd4';
                    } else {
                        btn.style.background = '#232837';
                        btn.style.color = '#fff';
                        btn.style.borderColor = '#2e3448';
                    }
                });
            }
            modeBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    currentMode = btn.getAttribute('data-mode');
                    updateModeBtns();
                    updateChart();
                });
            });
            updateModeBtns();
        }
        main();
    </script>
</body>
</html>
