<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GalaxyProspect Dashboard</title>
    <script src="./echarts.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
        <div class="layout">
            <aside class="sidebar">
                <!-- View Mode Icon -->
                <div class="sidebar-icon mode-panel-icon" data-panel="mode" title="Chart Mode">
                    <svg viewBox="0 0 32 32" fill="none">
                        <circle cx="16" cy="16" r="13" stroke="currentColor" stroke-width="3" fill="none"/>
                        <g>
                            <rect x="8" y="10" width="4" height="12" rx="1.2" fill="currentColor" opacity="0.7"/>
                            <rect x="14" y="6" width="4" height="16" rx="1.2" fill="currentColor"/>
                            <rect x="20" y="14" width="4" height="8" rx="1.2" fill="currentColor" opacity="0.7"/>
                        </g>
                    </svg>
                </div>
                <!-- Series Checkboxes Icon -->
                <div class="sidebar-icon" data-panel="series" title="Series Selection">
                    <svg viewBox="0 0 32 32" fill="none">
                        <rect x="3" y="13" width="6" height="16" rx="2" fill="currentColor"/>
                        <rect x="13" y="7" width="6" height="22" rx="2" fill="currentColor"/>
                        <rect x="23" y="17" width="6" height="12" rx="2" fill="currentColor"/>
                    </svg>
                </div>
            </aside>
            <div class="main-window">
                <div id="chart-container"><div id="casinoChart"></div></div>
            </div>
            <div class="floating-panel" id="panel-mode">
                <div class="checkbox-group mode-panel-group">
                    <label class="mode-panel-label">Chart Mode:</label>
                    <div id="mode-options" class="mode-options">
                        <button class="mode-btn" data-mode="raw">Raw</button>
                        <button class="mode-btn" data-mode="normalized">Normalized</button>
                        <button class="mode-btn" data-mode="indexed">Indexed</button>
                    </div>
                </div>
            </div>
            <div class="floating-panel" id="panel-series">
                <div id="series-categories" class="series-categories">
                </div>
            </div>
        </div>

    <script>

        // Sidebar panel hover logic for two icons
        document.addEventListener('DOMContentLoaded', function() {
            const icons = [
                { icon: document.querySelector('.sidebar-icon[data-panel="mode"]'), panel: document.getElementById('panel-mode') },
                { icon: document.querySelector('.sidebar-icon[data-panel="series"]'), panel: document.getElementById('panel-series') }
            ];
            let panelTimeout = null;
            icons.forEach(({icon, panel}) => {
                icon.addEventListener('mouseenter', (e) => {
                    document.querySelectorAll('.floating-panel').forEach(p => p.classList.remove('active'));
                    if (panel) {
                        const rect = icon.getBoundingClientRect();
                        const sidebarWidth = icon.parentElement.offsetWidth;
                        panel.style.display = 'block';
                        const panelHeight = panel.offsetHeight || 480;
                        panel.style.display = '';
                        let top = rect.top + window.scrollY + rect.height/2 - panelHeight/2;
                        top = Math.max(16, Math.min(top, window.innerHeight - panelHeight - 16));
                        panel.style.left = sidebarWidth + 'px';
                        panel.style.top = top + 'px';
                        panel.classList.add('active');
                        icon.classList.add('active');
                    }
                });
                icon.addEventListener('mouseleave', () => {
                    panelTimeout = setTimeout(() => {
                        if (panel) panel.classList.remove('active');
                        icon.classList.remove('active');
                    }, 200);
                });
                if (panel) {
                    panel.addEventListener('mouseenter', () => {
                        clearTimeout(panelTimeout);
                        panel.classList.add('active');
                        icon.classList.add('active');
                    });
                    panel.addEventListener('mouseleave', () => {
                        panel.classList.remove('active');
                        icon.classList.remove('active');
                    });
                }
            });
        });

        // Load config.json for symbol metadata and categories
    let configData = { symbols: [] };
        let symbolNames = {};
        let symbolCategories = { company: [], index: [], fx: [], commodity: [], macro: [] };
        function categorizeSymbols() {
            symbolCategories = { company: [], index: [], fx: [], commodity: [], macro: [] };
            (configData.symbols || []).forEach(item => {
                symbolNames[item.symbol_name] = item.desc;
                // Categorize based on symbol_name pattern or desc
                if (item.server === 'YF') {
                    if (/\.HK$/.test(item.symbol_name)) symbolCategories.company.push(item.symbol_name);
                    else if (/\^HSI|\.SS$|\.SZ$/.test(item.symbol_name)) symbolCategories.index.push(item.symbol_name);
                    else if (/=X$|NYB$/.test(item.symbol_name)) symbolCategories.fx.push(item.symbol_name);
                    else if (/=F$/.test(item.symbol_name)) symbolCategories.commodity.push(item.symbol_name);
                } else if (item.server === 'FRED') {
                    symbolCategories.macro.push(item.symbol_name);
                }
            });
        }

        async function fetchConfig() {
            const res = await fetch('config.json');
            configData = await res.json();
            categorizeSymbols();
        }

        async function fetchData() {
            // Fetch unified data.json only
            const res = await fetch('/api/data');
            return await res.json();
        }

        function getColor(idx) {
            // High-contrast, colorblind-friendly palette for dark backgrounds
            const baseColors = [
                '#FFD600', // Galaxy - Vivid Yellow
                '#00E676', // SJM - Bright Green
                '#FF1744', // Wynn - Vivid Red
                '#2979FF', // Sands - Bright Blue
                '#F500A3', // MGM - Magenta
                '#FF9100', // Melco - Orange
                '#00B8D4', // Hang Seng - Cyan
                '#C51162', // Shanghai - Deep Pink
                '#AEEA00'  // Shenzhen - Lime
            ];
            // Convert hex to rgba with alpha 0.9
            function hexToRgba(hex, alpha) {
                hex = hex.replace('#', '');
                if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
                const num = parseInt(hex, 16);
                const r = (num >> 16) & 255;
                const g = (num >> 8) & 255;
                const b = num & 255;
                return `rgba(${r},${g},${b},${alpha})`;
            }
            return hexToRgba(baseColors[idx % baseColors.length], 0.9);
        }

    function prepareEChartsOption(selectedSymbols, data, normalized, indexed, opts = {}) {
        // Helper for K/M/B formatting
        function formatKMB(val) {
            if (val == null || isNaN(val)) return '';
            if (Math.abs(val) >= 1e9) return (val / 1e9).toFixed(2).replace(/\.00$/, '') + 'b';
            if (Math.abs(val) >= 1e6) return (val / 1e6).toFixed(2).replace(/\.00$/, '') + 'm';
            if (Math.abs(val) >= 1e3) return (val / 1e3).toFixed(2).replace(/\.00$/, '') + 'k';
            return val.toLocaleString();
        }
            // Always use the full union of all dates from all symbols for a stable x-axis
            // Generate a complete calendar date range from min to max date in the data
            let minDate = null, maxDate = null;
            Object.values(data).forEach(symbolData => {
                Object.keys(symbolData).forEach(date => {
                    const d = new Date(date);
                    if (!minDate || d < minDate) minDate = d;
                    if (!maxDate || d > maxDate) maxDate = d;
                });
            });
            function formatDate(d) {
                const m = (d.getMonth() + 1).toString().padStart(2, '0');
                const day = d.getDate().toString().padStart(2, '0');
                return `${d.getFullYear()}-${m}-${day}`;
            }
            const sortedDates = [];
            if (minDate && maxDate) {
                for (let d = new Date(minDate); d <= maxDate; d.setDate(d.getDate() + 1)) {
                    sortedDates.push(formatDate(d));
                }
            }
            // Compute y-axis min/max based on visible (non-null) values in the current window for selected series
            let yMin = undefined, yMax = undefined;
            if (normalized) {
                yMin = 0;
                yMax = 1.05;
            } else if (indexed) {
                yMin = 0;
                yMax = undefined;
            } else if (selectedSymbols.length > 0) {
                let windowRange = opts.windowRange || [0, sortedDates.length - 1];
                let allVisible = [];
                selectedSymbols.filter(symbol => data[symbol]).forEach(symbol => {
                    const entries = Object.entries(data[symbol]);
                    const dateToAdjClose = Object.fromEntries(entries.map(([date, v]) => [date, v['Adj Close'] ?? null]));
                    let values = sortedDates.map(date => dateToAdjClose[date] ?? null);
                    // Only consider values in the current window
                    values = values.slice(windowRange[0], windowRange[1] + 1);
                    allVisible.push(...values.filter(v => v != null && isFinite(v)));
                });
                if (allVisible.length > 0) {
                    yMin = Math.min(...allVisible);
                    yMax = Math.max(...allVisible);
                    if (yMin === yMax) {
                        // Add a small buffer if all values are the same
                        yMin = yMin * 0.98;
                        yMax = yMax * 1.02;
                    }
                }
            }
            // Prepare series for each symbol
            const series = selectedSymbols.map((symbol, idx) => {
                if (!data[symbol]) return null; // skip if data missing
                const entries = Object.entries(data[symbol]);
                // Only use 'Adj Close', never fallback to 'Close'
                const dateToAdjClose = Object.fromEntries(entries.map(([date, v]) => [date, v['Adj Close'] ?? null]));
                let values = sortedDates.map(date => dateToAdjClose[date] ?? null);
                let actualValues = values.slice();
                if (normalized && values.filter(v => v != null).length > 0) {
                    // Min-max normalization: (value - min) / (max - min) within zoom window
                    let min, max, range;
                    if (opts.windowRange) {
                        const [start, end] = opts.windowRange;
                        const windowVals = values.slice(start, end + 1).filter(v => v != null);
                        min = windowVals.length ? Math.min(...windowVals) : 0;
                        max = windowVals.length ? Math.max(...windowVals) : 0;
                        range = max - min;
                        // Store actual values for tooltip
                        actualValues = values.slice();
                        values = values.map((v, i) => {
                            if (v == null) return null;
                            if (i < start || i > end) return null;
                            return range === 0 ? 0 : (v - min) / range;
                        });
                    } else {
                        const valid = values.filter(v => v != null);
                        min = Math.min(...valid);
                        max = Math.max(...valid);
                        range = max - min;
                        // Store actual values for tooltip
                        actualValues = values.slice();
                        values = values.map(v => v == null ? null : (range === 0 ? 0 : (v - min) / range));
                    }
                } else if (indexed && values.filter(v => v != null).length > 0 && opts.windowRange) {
                    // Indexed mode: divide by first non-null value in the current window
                    const [start, end] = opts.windowRange;
                    const windowVals = values.slice(start, end + 1);
                    const firstIdxInWindow = windowVals.findIndex(v => v != null);
                    const base = firstIdxInWindow !== -1 ? windowVals[firstIdxInWindow] : null;
                    // Store actual values for tooltip
                    actualValues = values.slice();
                    values = values.map((v, i) => {
                        if (v == null) return null;
                        if (base == null) return null;
                        return i >= start && i <= end ? v / base : null;
                    });
                }
                return {
                    name: symbol + ' (' + (symbolNames[symbol] || symbol) + ') Adj Close',
                    type: 'line',
                    data: values,
                    yAxisIndex: 0,
                    showSymbol: false,
                    connectNulls: true,
                    lineStyle: { width: 2, color: getColor(idx) },
                    itemStyle: { color: getColor(idx) },
                    emphasis: { focus: 'series' },
                    tooltip: {
                        valueFormatter: function (value, i) {
                            if ((normalized || indexed) && typeof value === 'number' && typeof actualValues[i] === 'number') {
                                return value.toFixed(3) + ' (actual: ' + formatKMB(actualValues[i]) + ')';
                            } else if (typeof value === 'number') {
                                return formatKMB(value);
                            } else {
                                return 'N/A';
                            }
                        }
                    }
                };
            }).filter(Boolean);
            // Show volume bars for any single selected symbol (company or index) if volume data exists
            if (selectedSymbols.length === 1) {
                const symbol = selectedSymbols[0];
                const entries = Object.entries(data[symbol]);
                // Try both 'Volume' and 'volume' keys for robustness
                const dateToVolume = Object.fromEntries(entries.map(([date, v]) => [date, v['Volume'] ?? v['volume'] ?? null]));
                // Debug: log volume data for selected symbol
                // Only add if there is at least some volume data
                if (Object.values(dateToVolume).some(v => v != null)) {
                    // Outlier filter: if a value is >10x the previous max, treat as null
                    let prevMax = null;
                    const filteredVolumeArray = sortedDates.map(date => {
                        const v = dateToVolume[date] ?? null;
                        if (v == null) return null;
                        if (prevMax === null) {
                            prevMax = v;
                            return v;
                        }
                        if (v > prevMax * 10) {
                            return null;
                        }
                        if (v > prevMax) prevMax = v;
                        return v;
                    });
                    series.push({
                        name: symbol + ' (' + (symbolNames[symbol] || symbol) + ') Volume',
                        type: 'bar',
                        data: filteredVolumeArray,
                        yAxisIndex: 1,
                        itemStyle: {
                            color: (symbol === '^HSI') ? '#00B8D4' : (symbol === '000001.SS') ? '#C51162' : (symbol === '399001.SZ') ? '#AEEA00' : '#FFD600',
                            opacity: 0.25
                        },
                        emphasis: { focus: 'series' },
                        tooltip: { valueFormatter: v => v != null ? formatKMB(v) : 'N/A' }
                    });
                }
            }
            // Always use linear scale for volume, and set min/max dynamically for visible volume data
            let volumeMin = null, volumeMax = null;
            if (selectedSymbols.length === 1) {
                const symbol = selectedSymbols[0];
                const entries = Object.entries(data[symbol]);
                const volumes = entries.map(([date, v]) => v['Volume'] ?? v['volume']).filter(v => v != null);
                if (volumes.length > 0) {
                    volumeMin = Math.min(...volumes);
                    volumeMax = Math.max(...volumes);
                }
            }
            // Default to last 36 months (about 756 trading days)
            const defaultMonths = 36;
            const defaultDays = defaultMonths * 21; // ~21 trading days per month
            const defaultWindow = sortedDates.length > defaultDays ? Math.round((sortedDates.length - defaultDays) / sortedDates.length * 100) : 0;
            return {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'cross',
                        crossStyle: {
                            color: '#00bcd4',
                            width: 1.5
                        },
                        label: {
                            backgroundColor: '#232837',
                            color: '#fff',
                            borderColor: '#00bcd4',
                            borderWidth: 1,
                            fontWeight: 'bold',
                            fontSize: 13,
                            fontFamily: 'MCI',
                            padding: [6, 12],
                            shadowColor: '#000',
                            shadowBlur: 6
                        }
                    },
                    backgroundColor: '#232837',
                    borderColor: '#fff',
                    textStyle: { color: '#fff', fontFamily: 'MCI' }
                },
                legend: { show: false, textStyle: { fontFamily: 'MCI' } },
                grid: { left: 60, right: 60, top: 85, bottom: 90 },
                dataZoom: [
                    {
                        type: 'slider',
                        show: true,
                        xAxisIndex: 0,
                        // Show only the most recent 36 months (about 756 trading days) by default
                        start: defaultWindow,
                        end: 100,
                        height: 22,
                        bottom: null,
                        top: 0, // Place slider at the very top of the chart area
                        backgroundColor: '#232837',
                        borderColor: '#333',
                        fillerColor: 'rgba(0,188,212,0.18)',
                        handleIcon: 'M8.7,11.3v-8.6h2.6v8.6H8.7z',
                        handleSize: '120%',
                        moveHandleSize: '100%',
                        showDetail: true,
                        handleStyle: { color: '#00bcd4' },
                        textStyle: { color: '#fff' }
                    }
                ],
                xAxis: {
                    type: 'category',
                    data: sortedDates,
                    axisLabel: {
                        rotate: 0, // Print horizontally
                        color: '#fff',
                        fontWeight: 500,
                        interval: 'auto', // Let ECharts auto-calculate, but force minInterval below
                        minInterval: 1, // Allow every tick if space
                        hideOverlap: true, // Never overlap
                        fontFamily: 'MCI',
                        letterSpacing: 2
                        // Always show at least 4 ticks: if ECharts shows fewer, force 4 evenly spaced
                        ,formatter: function(value, index) {
                            const total = sortedDates.length;
                            // If ECharts would show fewer than 4, force 4 evenly spaced
                            if (this.axis && this.axis.getViewLabels) {
                                const labels = this.axis.getViewLabels();
                                if (labels.length < 4) {
                                    const step = Math.max(1, Math.floor(total / 4));
                                    if (index % step !== 0 && index !== total - 1 && index !== 0) return '';
                                }
                            }
                            return value;
                        }
                    },
                    axisLine: { lineStyle: { color: '#fff' } }
                },
                yAxis: [
                    {
                        type: 'value',
                        name: normalized ? 'Normalized Adj Close' : 'Adj Close',
                        position: 'left',
                        axisLine: { show: true, lineStyle: { color: '#fff' } },
                        axisLabel: { formatter: v => normalized ? v.toFixed(2) : formatKMB(v), color: '#fff', fontWeight: 500, fontFamily: 'MCI', letterSpacing: 2 },
                        nameTextStyle: { color: '#fff', fontWeight: 600, fontFamily: 'MCI', letterSpacing: 2 },
                        splitLine: { lineStyle: { color: '#333' } },
                        min: yMin,
                        max: yMax
                    },
                    {
                        type: 'value',
                        name: 'Volume',
                        position: 'right',
                        axisLine: { show: true, lineStyle: { color: '#fff' } },
                        axisLabel: { formatter: v => v != null ? formatKMB(v) : '', color: '#fff', fontWeight: 500, fontFamily: 'MCI', letterSpacing: 2 },
                        nameTextStyle: { color: '#fff', fontWeight: 600, fontFamily: 'MCI', letterSpacing: 2 },
                        splitLine: { show: false },
                        min: 0,
                        max: undefined
                    }
                ],
                series: series.map(s => s.type === 'bar' ? { ...s, barMinWidth: 3 } : s)
            };
        }

        async function main() {
            await fetchConfig();
            const data = await fetchData();
            const symbols = Object.keys(data);

            // Debug: log loaded data and selected symbols
            console.log('Loaded data:', data);
            console.log('Symbols:', symbols);

            // Use config-driven categories
            const companySymbols = symbolCategories.company.filter(sym => data[sym]);
            const indexSymbols = symbolCategories.index.filter(sym => data[sym]);
            const fxSymbols = symbolCategories.fx.filter(sym => data[sym]);
            const commoditySymbols = symbolCategories.commodity.filter(sym => data[sym]);
            const macroSymbols = symbolCategories.macro.filter(sym => data[sym]);


            // CATEGORY BLOCKS: each category is a vertical block (label + checkboxes)
            const seriesCategories = document.getElementById('series-categories');
            seriesCategories.innerHTML = '';
            function createCategoryBlock(cat, labelText, syms) {
                const block = document.createElement('div');
                block.className = 'category-block';
                // Category label
                const label = document.createElement('div');
                label.className = 'category-label';
                const catCheckbox = document.createElement('input');
                catCheckbox.type = 'checkbox';
                catCheckbox.className = 'category-checkbox';
                catCheckbox.setAttribute('data-category', cat);
                label.appendChild(catCheckbox);
                label.appendChild(document.createTextNode(labelText));
                // Make the whole label clickable to toggle the checkbox
                label.addEventListener('click', function(e) {
                    // Only toggle if the click is not directly on the checkbox itself
                    if (e.target !== catCheckbox) {
                        // Find all child checkboxes in this block
                        const block = label.closest('.category-block');
                        if (!block) return;
                        const cbs = Array.from(block.querySelectorAll('input[type=checkbox][value]'));
                        // Determine if all are checked
                        const allChecked = cbs.every(cb => cb.checked);
                        // Toggle all: if all checked, uncheck all; else check all
                        cbs.forEach(cb => { cb.checked = !allChecked; });
                        updateChart();
                        // Sync the cat checkbox to reflect children state
                        if (typeof syncCatCheckboxFns[cat] === 'function') syncCatCheckboxFns[cat]();
                    }
                });
                block.appendChild(label);
                // Series checkboxes
                syms.forEach(sym => {
                    const itemLabel = document.createElement('label');
                    itemLabel.setAttribute('data-symbol', sym);
                    itemLabel.style.marginRight = '1em';
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.value = sym;
                    cb.checked = false;
                    itemLabel.appendChild(cb);
                    itemLabel.appendChild(document.createTextNode(' ' + (symbolNames[sym] || sym)));
                    itemLabel.title = sym;
                    block.appendChild(itemLabel);
                });
                return {block, catCheckbox};
            }
            let anyChecked = false;
            const catOrder = [
                {cat: 'company', label: 'COMPANIES', syms: companySymbols},
                {cat: 'index', label: 'MARKET INDEXES', syms: indexSymbols},
                {cat: 'fx', label: 'FX', syms: fxSymbols},
                {cat: 'commodity', label: 'COMMODITIES', syms: commoditySymbols},
                {cat: 'macro', label: 'MACRO', syms: macroSymbols}
            ];
            const catCheckboxes = {};
            catOrder.forEach(({cat, label, syms}) => {
                const {block, catCheckbox} = createCategoryBlock(cat, label, syms);
                // Check the first available company by default
                if (cat === 'company') {
                    for (const sym of syms) {
                        if (!anyChecked && sym && data[sym]) {
                            const cb = block.querySelector('input[type=checkbox][value="' + sym + '"]');
                            if (cb) { cb.checked = true; anyChecked = true; break; }
                        }
                    }
                }
                // Add a change listener to update the chart on any checkbox change in this block
                block.addEventListener('change', function(e) {
                    updateChart();
                });
                seriesCategories.appendChild(block);
                catCheckboxes[cat] = catCheckbox;
            });

            // Helper: batch check/uncheck children when category label is toggled
            // Store sync functions for each category
            const syncCatCheckboxFns = {};
            function setupCategoryBatchToggle(category, symbols, catCheckbox) {
                catCheckbox.addEventListener('change', function() {
                    const checked = catCheckbox.checked;
                    // Find the block for this category
                    const block = catCheckbox.closest('.category-block');
                    if (!block) return;
                    const cbs = Array.from(block.querySelectorAll('input[type=checkbox][value]'));
                    cbs.forEach(cb => { cb.checked = checked; });
                    updateChart();
                    // Always sync after batch toggle
                    if (typeof syncCatCheckboxFns[category] === 'function') syncCatCheckboxFns[category]();
                });
                function syncCatCheckbox() {
                    const block = catCheckbox.closest('.category-block');
                    if (!block) return;
                    const cbs = Array.from(block.querySelectorAll('input[type=checkbox][value]'));
                    const checkedCount = cbs.filter(cb => cb.checked).length;
                    if (checkedCount === cbs.length && cbs.length > 0) {
                        catCheckbox.checked = true;
                        catCheckbox.indeterminate = false;
                    } else if (checkedCount === 0) {
                        catCheckbox.checked = false;
                        catCheckbox.indeterminate = false;
                    } else {
                        catCheckbox.checked = false;
                        catCheckbox.indeterminate = true;
                    }
                }
                // Only listen for changes within this block
                const block = catCheckbox.closest('.category-block');
                if (block) {
                    block.addEventListener('change', function(e) {
                        if (!e.target.classList.contains('category-checkbox')) syncCatCheckbox();
                    });
                }
                syncCatCheckboxFns[category] = syncCatCheckbox;
                syncCatCheckbox();
            }
            setupCategoryBatchToggle('company', companySymbols, catCheckboxes['company']);
            setupCategoryBatchToggle('index', indexSymbols, catCheckboxes['index']);
            setupCategoryBatchToggle('fx', fxSymbols, catCheckboxes['fx']);
            setupCategoryBatchToggle('commodity', commoditySymbols, catCheckboxes['commodity']);
            setupCategoryBatchToggle('macro', macroSymbols, catCheckboxes['macro']);

            function getSelectedSymbols() {
                // All checked series checkboxes in all blocks
                return Array.from(document.querySelectorAll('.category-block label input[type=checkbox]:checked')).map(cb => cb.value);
            }

            let currentMode = 'raw';
            function getModeStates() {
                return {
                    normalized: currentMode === 'normalized',
                    indexed: currentMode === 'indexed'
                };
            }
            let selectedSyms = getSelectedSymbols();
            console.log('Selected symbols for chart:', selectedSyms);
            let chartOption = prepareEChartsOption(
                selectedSyms,
                data,
                getModeStates().normalized,
                getModeStates().indexed
            );
            const casinoChart = echarts.init(document.getElementById('casinoChart'));
            casinoChart.setOption(chartOption);
            // Responsive: resize chart on window resize
            window.addEventListener('resize', () => {
                casinoChart.resize();
            });

            function updateCheckboxColors() {
                // Get current selected symbols in order
                const selected = getSelectedSymbols();
                // For each selected symbol, set its label color to the palette color for its current index
                selected.forEach((sym, idx) => {
                    const label = document.querySelector('label[data-symbol="' + sym + '"]');
                    if (label) label.style.color = getColor(idx);
                });
                // For unselected, set color to #b0b4c1 (default)
                [...companySymbols, ...indexSymbols, ...fxSymbols, ...commoditySymbols, ...macroSymbols].forEach(sym => {
                    if (!selected.includes(sym)) {
                        const label = document.querySelector('label[data-symbol="' + sym + '"]');
                        if (label) label.style.color = '#b0b4c1';
                    }
                });
            }
            function getCurrentWindowRange() {
                // Get current dataZoom window (returns [startIdx, endIdx])
                const option = casinoChart.getOption();
                const dz = option.dataZoom && option.dataZoom[0];
                const total = option.xAxis[0].data.length;
                const start = dz ? Math.round((dz.start / 100) * (total - 1)) : 0;
                const end = dz ? Math.round((dz.end / 100) * (total - 1)) : total - 1;
                return [start, end];
            }
            function updateChart() {
                const selected = getSelectedSymbols();
                const { normalized, indexed } = getModeStates();
                // Always get the current window range for indexed or normalized mode
                let windowRange = undefined;
                if (indexed || normalized) {
                    windowRange = getCurrentWindowRange();
                }
                const newOption = prepareEChartsOption(selected, data, normalized, !normalized && indexed, { windowRange });
                // Always preserve the current dataZoom window
                const option = casinoChart.getOption();
                if (option.dataZoom && option.dataZoom[0]) {
                    newOption.dataZoom[0].start = option.dataZoom[0].start;
                    newOption.dataZoom[0].end = option.dataZoom[0].end;
                }
                // Hide tooltip before updating chart to avoid DOM errors
                try { casinoChart.dispatchAction({ type: 'hideTip' }); } catch (e) {}
                casinoChart.clear();
                casinoChart.setOption(newOption, { notMerge: true, replaceMerge: ['series'] });
                updateCheckboxColors();
                // Sync all category checkboxes after chart update
                Object.values(syncCatCheckboxFns).forEach(fn => fn());
            }
            // Listen for zoom events to update rebasing
            let chartReady = false;
            casinoChart.on('dataZoom', function() {
                if (chartReady) updateChart();
            });
            chartReady = true;
            // Initial color sync
            updateCheckboxColors();
            // All change events now handled by the category-block listeners
            // Mode button logic
            const modeBtns = document.querySelectorAll('.mode-btn');
            function updateModeBtns() {
                modeBtns.forEach(btn => {
                    if (btn.getAttribute('data-mode') === currentMode) {
                        btn.style.background = '#00bcd4';
                        btn.style.color = '#181c24';
                        btn.style.borderColor = '#00bcd4';
                    } else {
                        btn.style.background = '#232837';
                        btn.style.color = '#fff';
                        btn.style.borderColor = '#2e3448';
                    }
                });
            }
            modeBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    currentMode = btn.getAttribute('data-mode');
                    updateModeBtns();
                    updateChart();
                });
            });
            updateModeBtns();
        }
        main();
    </script>
</body>
</html>
